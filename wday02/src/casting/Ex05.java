package casting;

public class Ex05 {
	public static void main(String[] args) {
		// 자료형 변환
		// 1) 대입연산은 우변의 값을 좌변의 공간에 복사하여 저장한다
		// 2) 대입연산의 우변에는 변수, 상수 등 여러 형태가 올 수 있다
		// 3) 대입연산의 좌변에는 변수만 와야 한다
		
		int n1 = 10;
		final int n2 = 20;	
		// n2변수에 20을 담고, 더이상 값을 변경하지 못하도록 상수화한다
		
		n1 = 30;	// 30을 n1변수에 저장한다 (기존 값은 덮어씌워지면서 사라진다)
//		n2 = 30;	// n2 변수는 더이상 값을 변경할 수 없다
		
		// 4) 좌변과 우변이 동일하지는 않지만, 자료형은 같거나 서로 호환되는 형식이여야 한다
		byte by = 10;
		short sh = 20;
		int num = 30;
		
//		by = n1;	// by변수의 크기는 1바이트인데, n1의 크기는 4바이트
		sh = by;	// sh변수의 크기는 2바이트인데, by의 크기는 1바이트
		// 5) 값 앞에 ()를 붙이고, ()안에 자료형을 명시하면, 값의 자료형을 바꿔준다
		by = (byte)n1;	// n1의 값을 byte형태로 변환한 후 by변수에 담는다

		// 변경하는 자료형을 값 앞에 명시하는 형태를 명시적 형변환, 강제형변환이라고 한다
		
		// 6) 왼쪽의 자료형이 더 크면, 명시하지 않아도 자동으로 자료형이 바뀐다
		// 이를 암묵적 형변환이라고 한다
		num = by;	// num변수의 크기는 4바이트인데, by의 크기는 1바이트
		
		// 7) 자료형 변환에는 자료형의 크기뿐 아니라, 자료형의 값 표현범위도 포함된다
		// 정수보다 실수의 표현범위가 넓다
		float num1;		// 4바이트
		int num2;		// 4바이트
		
		num1 = 1.2F;	// double이 대표자료형이므로, float은 값에 F를 붙여서 표현한다
		num2 = 5;
		
//		num1 = num2;	// 크기는 같으나, int보다 float으로 표현가능한 형태가 더 많다
//		num2 = num1;	// num1의 소수점 이하 값이 잘려나갈 수 있다
		num2 = (int)num1;	// 강제형변환, 소수점 이하 자리가 잘려 나갈 수 있다
		
		System.out.println("num1 : " + num1);
		System.out.println("num2 : " + num2);
		
		char ch = 44032;		// 2바이트, 0 ~ 65535
		short sh2 = 0;			// 2바이트, -32768 ~ +32767
		
//		sh2 = ch;	// 둘다 정수, 둘다 2바이트. 하지만 대입할 수 없다
		sh2 = (short)ch;	// 오른쪽값의 형태를 왼쪽 변수에 맞춰서 강제 형변환한다
		
		System.out.println("ch : " + ch);
		System.out.println("sh2: " + sh2);
		
		// 8) 강제 형변환은 형태를 변환해도 데이터의 손실이 없거나
		// 데이터의 손실이 발생하지만, 감수할 수 있을 때 사용한다
		ch = 65;		// 값으로써의 65는 short 에 충분히 담기지만
//		sh2 = ch;		// 대입연산에서는 자료형을 보고 판단하기 때문에 경고가 발생한다
		sh2 = (short)ch;// 대입을 원하면 강제 형변환을 사용해야 한다
		
		System.out.println("ch : " + ch);
		System.out.println("sh2 : " + sh2);
		
		
		
		
		
		
		
		
		
		
	}
}
